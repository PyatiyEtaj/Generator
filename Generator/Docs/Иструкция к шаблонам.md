# **Инструкция по созданию шаблонов**

Предположим, что имеется некоторое задание и нужно сделать новую версию данного задания.

Изначальное задание имеет следующий вид :

> Написать программу для вычисления функции  y = f(x)
> - y = cos(x) / (x + 10) при x < -3
> - y = e ^ (0.1x)        при -3 <= x < 4
> - y = lg(x)            при 4 <= x < 6
> - y = sin(x)       при x >= 6

Для создания варианта, имеющегося задания, нужно сгенерировать новые выражения и диапазоны. Сгенерированные данные нужно подставить в следующие места :

> Написать программу для вычисления функции  y = f(x)
> - y = (выражение 1) при x < (1-ый диапазон)
> - y = (выражение 2) при (1-ый диапазон) <= x < (2-ой диапазон)
> - y = (выражение 3) при (2-ой диапазон) <= x < (3-ий диапазон)
> - y = (выражение 4) при x <= (3-ий диапазон)

Для генерации подобных задания нужно использовать шаблон расположеный в листинге 1. 

Листинг 1 - Шаблон задания
```
1. | ----
2. | ХРАНИЛИЩЕ_ОБЪЕКТОВ
3. | выражение 1 : #genAE(5);
4. | код 1 : #getAEcode();
5. | 
6. | выражение 2 : #genAE(5);
7. | код 2 : #getAEcode();
8. | 
9. | выражение 3 : #genAE(5);
10.| код 3 : #getAEcode();
11.| 
12.| выражение 4 : #genAE(5);
13.| код 4 : #getAEcode();
14.| 
15.| 1-ый диапазон : #rnd( 0.0  , 5.0  , double);
16.| 2-ой диапазон : #rnd( 5.0  , 10.0 , double);
17.| 3-ий диапазон : #rnd( 10.0 , 15.0 , double);
18.| 
19.| ----
20.| ШАБЛОННЫЙ_ВИД
21.| Написать программу для вычисления выражения :
22.| 
23.| - y = @выражение 1@ **где x1 < @1-ый диапазон@**
24.| - y = @выражение 2@ **где @1-ый диапазон@ <= x1 < @2-ой диапазон@**
25.| - y = @выражение 3@ **где @2-ой диапазон@ <= x1 < @3-ий диапазон@**
26.| - y = @выражение 4@ **где x1 >= @3-ий диапазон@**
27.| 
28.| ----
29.| РЕШЕНИЕ
30.| #include <cmath>
31.| #include <iostream>
32.| 
33.| using namespace std;
34.| 
35.| int main()
36.| {
37.|     double y = 0.0;
38.|     double x1;
39.|     cin >> x1;
40.| 
41.|     if ( x1 <  @1-ый диапазон@)
42.|     {        
43.|         @код 1@
44.|     }
45.|     else if (x1 >=  @1-ый диапазон@ && x1 < @2-ой диапазон@)
46.|     {
47.|         @код 2@
48.|     }
49.|     else if (x1 >= @2-ой диапазон@ && x1 < @3-ий диапазон@)
50.|     {
51.|     	@код 3@
52.|     }
53.|     else if (x1 >= @3-ий диапазон@)
54.|     {
55.|         @код 4@
56.|     }
57.|     cout << y << "\n";
58.|     system("pause");
59.|     return 0;
60.| }
70.| ----
71.| СЛУЖЕБНОЕ
72.|   знаки_арифм : + | - | * | / | ^;
73.| функции_арифм : sin | cos | sqrt | tan | log | log10;
74.| ----
75.| ТЕСТОВЫЕ_ДАННЫЕ
76.| Тест1 : #rnd(100 , 200 , int , 1000);
77.| Тест2 : 1, 2, 3, 4, 5, 6, 7, 8, 9, 10;
78.| ----
```

# **Описание блоков**

Шаблон задания состоит из пяти секций (листинг 1, строки: `2, 20, 29, 71, 75`), также необходимо обратить внимание на то, что начало каждой секции отделяется от предыдущей последовательностью символов : `----\n`, данная последовательность должна заканчиваться концом строки `\n`.

Листинг 2 - Секции шаблон-файла.
```
1. | ----
2. | ХРАНИЛИЩЕ_ОБЪЕКТОВ
         
19.| ----
20.| ШАБЛОННЫЙ_ВИД
        
28.| ----
29.| РЕШЕНИЕ
      
70.| ----
71.| СЛУЖЕБНОЕ
      
74.| ----
75.| ТЕСТОВЫЕ_ДАННЫЕ   
```

## Примечание: 

Для более удобного расшифровывания шаблон-файл есть набор метасимволов, который предназначен для резделения лексем. К ним относятся [ `: ; | " @` ]. Eсли необходимо использовать эти символы в качестве текстовых знаков, можно использовать экранирующий символ [ `\` ]. При подстановке в текст символ [ `\` ] будет убираться.


> ### Пример:
> **В данном случае все знаки используются для разделения лексем**
> - выражение 1 **:** sin x + 23 **|** x * 2 + x * x **;**
> 
> **В следующих примерах некоторые символы выступают в качестве текстовых знаков. При использовании данных объектов-параметров в тексте - символ `\` удалится**
> - задание : реализовать возведение в степень , не используя математическую библиотеку, для чисел в диапазоне [1 **\\;** 100];
> - знание : оператор **\\|\\|** является логическим ИЛИ;


## **Секция № 1 - ХРАНИЛИЩЕ_ОБЪЕКТОВ**

`ХРАНИЛИЩЕ_ОБЪЕКТОВ` - хранит объекты-параметры. 

`Объект-параметр` - переменная, хранящая строку (здесь подразумевается неограниченный набор символов). Объект-параметр может содержать как уже готовую последовательность символов так и исполняемую функцию (при вызове параметра где-либо в шаблоне функция сначала исполняется и подставляется уже результат, который выдала функция).

Объект-параметр имеет следующий синтаксис :
```
объект_параметр = “имя объекта-параметра” “:” значение_объекта_параметра {“|” значение_объекта_параметра} “;”
значение_объекта_параметра = “набор символов юникода” | функция
функция = “#имя_функции({аргументы функции [,]})”
```
Если описывать проще то синтаксис можно представить следующим образом (пробелы не играют никакой роли):
```
имя параметра : содержимое объекта параметра;
  выражение 1 : решите выражение - sin(x) + x * 10 + 5;
```

1. Имя параметра может содержать любые символы (исключение составляют специальные символы - [ ` : , ; | @ " \n` ]);
2. Cодержимое может являться либо функцией либо уже готовым значением, перемешивание недопустимо;
3. Объекту-параметру изнально можно задать несколько значений, используя символ [ `|` ]. В дальнейшем выберется одно случайное значение, которое и будет использоваться.

Далее построчно опишем используемые объекты-параметры из листинга 1.

#### Функция #genAE(x)
Обратимся к строкам: `3, 6, 9, 12`
```
3. | выражение 1 : #genAE(5);
6. | выражение 2 : #genAE(5);
9. | выражение 3 : #genAE(5);
12.| выражение 4 : #genAE(5);
```
Здесь объекты-параметры содержат исполняемую функцию `#genAE(х)` - данная функция генерирует арифметическое выражения сложностью `х` (сумма знаков и функций: sin, cos, log и т.д.).

Пример:
```
 было = выражение 1 : #genAE(5);
стало = выражение 1 : cos(-99.45 + log(51.01 - (18.82 * x1)));
```
#### Функция #getAEcode()
Теперь посмотрим на строки: `4, 7, 10, 13`
```
4. | код 1 : #getAEcode();
7. | код 2 : #getAEcode();
10.| код 3 : #getAEcode();
13.| код 4 : #getAEcode();
```
Здесь объекты-параметры содержат исполняемую функцию `#getAEcode()` - функция, генерирующая код на языке `C++` для вычисления последнего сгенерированного арифметическое выражения (код содержит само выражение, а также условия при которых оно вычисляется).

Пример :

```
было =
    выражение 1 : #genAE(5);
    код 1 : #getAEcode();

стало =
    выражение 1 : cos(-99.45 + log(51.01 - (18.82 * x1)));
    код 1 : if (((51.01 - (18.82 * x1)) > 0 && (51.01 - (18.82 * x1)) != 1))
                 y = cos(-99.45 + log(51.01 - (18.82 * x1)));
            else 
                 y = 0.0;
```
#### Функция #rnd(min, max, type)

Строки:  `15-17`
```
15.| 1-ый диапазон : #rnd( 0.0  , 5.0  , double);
16.| 2-ой диапазон : #rnd( 5.0  , 10.0 , double);
17.| 3-ий диапазон : #rnd( 10.0 , 15.0 , double);
```

Объекты-параметры из данных строк содержат исполняемую функцию `#rnd(min, max, type)` - функция, генерирующая случайное число в диапазоне [`min` ; `max`] типа `type` (на данный момент можно использовать значения `int` и `double`).

Пример:
```
 было = 1-ый диапазон : #rnd(1, 10, int);
стало = 1-ый диапазон : 5;
```

_Полное описание доступных функций будет изложено в конце документа._
### Подстановка объектов-параметров
На данном этапе стало более понятно что представляют собой объекты-параметры. Теперь нужно сказать о там как их использовать, все довольно просто, чтобы использовать параметр нужно прибегнуть к следующему синтаксису:
```
@имя_объекта_параметра@
```
**Между знаками `@` и `имя_объекта_параметра` пробелов быть не должно.**

Пример использования подстановок:
```
было = 
    количество : 100;
    задание: запишите в файл 'Input.txt' @количество@ знаков;

стало = 
    количество : 100;
    задание: запишите в файл 'Input.txt' 100 знаков;

```

## **Секция 2 - ШАБЛОННЫЙ_ВИД**

Данная секция шаблон-файла содержит конкретный вид варианта задания. В данном блоке можно и нужно использовать ранее описанные объекты-параметры.

Обратимся к строкам `19-26`
```
19.| ----
20.| ШАБЛОННЫЙ_ВИД
21.| Написать программу для вычисления выражения :
22.| 
23.| - y = @выражение 1@ **где x1 < @1-ый диапазон@**
24.| - y = @выражение 2@ **где @1-ый диапазон@ <= x1 < @2-ой диапазон@**
25.| - y = @выражение 3@ **где @2-ой диапазон@ <= x1 < @3-ий диапазон@**
26.| - y = @выражение 4@ **где x1 >= @3-ий диапазон@**
```

Данный блок содержит задание в которое будут подставляться ранее описанные объекты-параметры: `@выражение 1@`, `@выражение 2@`, `@выражение 3@`, `@выражение 4@`, `@1-ый диапазон@`, `@2-ый диапазон@`, `@3-ый диапазон@`. 

Примечание:
Посмотрим на строку 23

> 23.| `-` y = @выражение 1@ `**`где x1 < @1-ый диапазон@`**`

Помеченные символы являются частью языка разметки `markdown` и используются для форматирования текста, использование `markdown` не является обязательным, если у вас нет времени на изучение `markdown`, вы можете игнорировать использование данного языка и описывать все так как вы привыкли.

Примерный вид готового задания с использованием форматирования может выглядеть следующим образом:

> Написать программу для вычисления выражения :
> 
> - y = (x1 - (-6 * x1)) + 3 **где x1 < 3**
> - y = log(cos(pow(1, (-6 * x1)))) **где 3 <= x1 < 7**
> - y = -10 + (sin(9 - x1) * 8) **где 7 <= x1 < 14**
> - y = sqrt(6 - (-1 + x1)) **где x1 >= 14**

## **Секция 3 - РЕШЕНИЕ**

`РЕШЕНИЕ` - хранит эталонное решения для задания. Эталонное решение компилируется и используется для тестирования других программ предназначенных для выполнения поставленных задач.

Данная секция является копией `ШАБЛОННОГО_ВИДА`, здесь также можно использовать объекты-параметры. Отличительная черта данного блока это данные, а именно код который должен успешно компилироваться или интерпретироваться, привязки к определенному ЯП нет. Из _'коробки'_ генератор обращается к модулю проверки заданий, который компилирует эталонное решения, используя `g++` (подразумевается, что решение написано ЯП `C++`). В случае если эталонное решение написано на другом языке, можно использовать флаг `compile=false`, тогда генератор будет создавать лишь код, без последующей компиляции.

Эталонное решение описано в листинге 1 в строках: `28-60`.

## **Секция 4 - СЛУЖЕБНОЕ**

`СЛУЖЕБНОЕ` - секция отвечающая за настройку генератора. На данный момент есть лишь 2 параметра :

* `знаки_арифм` – отвечает за символы, которые будут использоваться во время генерации арифметических выражений;
* `функции_арифм` – отвечает за функции, которые будут использоваться во время генерации арифметических выражений.

Данная секция представлна в листинге 1 в строках `71-73`.

## **Секция 5 - ТЕСТОВЫЕ_ДАННЫЕ**

`ТЕСТОВЫЕ_ДАННЫЕ` - секция которая содержит данные для тестирования эталонного решения и решения, присланного обучаемым;

Данный блок схож с `ХРАНИЛИЩЕМ_ОБЪЕКТОВ`, здесь также описываются объекты-параметры. В данной секции можно указывать заготовленные данные через запятую или же использовать какие-либо функции, например использовать функцию для генерации большого количества случайных чисел в диапазоне и т.д.


Данная секция представлна в листинге 1 в строках `75-77`.

# Полное описание доступных функций:
 * `#rnd ( нижняя_граница , верхняя_граница , тип {, количество})` - генерирует случайное число в границе [ нижняя_граница, верхняя_граница) типа `тип (double или int)`. Если необходимо сгенерировать сразу несколько значений используется дополнительный параметр “количество”, в таком случае сгенерированные числа будут разделены запятыми;
    ```
     было = число : #rnd(1, 10, int);
    стало = число : 5;
    ```
  
 * `#genAE(сложность {, граница , тип , количество переменных})` - генерирует выражение некоторой сложности (сложность указывает количество знаков и функций (например log, sin и т.д.)), граница указывает диапазон генерации констант [-граница, граница), тип указывает на тип генерируемых констант (`double` или `int`), количество переменных, указывает на зависимость выражения от количества переменных (от 1 до бесконечности);
    ```
     было = выр : #genAE(5);
    стало = выр : cos(-99.45 + log(51.01 - (18.82 * x1)));

     было = выр2 : #genAE(5 , 50.0 , double , 2);
    стало = выр2 : (x1 / ((x2 + tan(x1)) * 18.82)) + x1;
    ```
 * `#getAEcode()` - возвращает код для вычисления последнего сгенерированного выражения (вместе с проверками на возможность вычисления выражения) на языке `C++`.
    ```
    было =
        выр : #genAE(5);
        код : #getAEcode();

    стало =
        выр : cos(-99.45 + log(51.01 - (18.82 * x1)));
        код : if (((51.01 - (18.82 * x1)) > 0 && (51.01 - (18.82 * x1)) != 1))
                   y = cos(-99.45 + log(51.01 - (18.82 * x1)));
              else 
                   y = 0.0;
    ```
 * `#lua(код_на_луа)` - данная функция является второстепенной и предназначена для выполнения кода на `Lua` (изначально предполагалось использовать `Lua` лишь для вычисления мат. выражений, но в дальнейшем данный язые будет использовать для расширения предоставляемого функционала генератора). Все системные функции (кроме получения времени и даты) на `Lua` которые обращаются к OS запрещены в целях безопасности.
    ```
    было =
        число : #lua("
                math.randomseed(12345689);
                return math.random(100);
            ");
    стало =
        число : 88;
    ```

