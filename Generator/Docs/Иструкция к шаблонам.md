# **Инструкция по созданию шаблонов**

Предположим, что имеется некоторое задание и нужно сделать новую версию данного задания.

Листинг 1 - Первоначальное задание
> Написать программу для вычисления функции  $y = f(x)$
> - $y = \frac{\cos{x}}{(x + 10)}$ при x < -3
> - $y = e^{0.1x}$        при -3 <= x < 4
> - $y = \lg{x}$            при 4 <= x < 6
> - $y = \sin{x}$       при x >= 6

Для создания нового варианта необходимо выделить основные части задания: 
* Статические - общие для всех вариантов части;
* Динамические - генерируемые части.

Листинг 2 - общий вид задания
> Написать программу для вычисления функции y = f(x)
> - y = @выражение 1@ при x < @1-ый диапазон@
> - y = @выражение 2@ при @1-ый диапазон@ <= x < @2-ой диапазон@
> - y = @выражение 3@ при @2-ой диапазон@ <= x < @3-ий диапазон@
> - y = @выражение 4@ при x <= @3-ий диапазон@

В листинге 2 динамические части были помещены между символами `@`. При создании нового варианта, внимание будет уделяться только данным частям.

Опишем шаблон для генератора и разберем каждую часть шаблона по отдельности.

Листинг 3 - Шаблон задания
```
1. | ----
2. | ШАБЛОННЫЙ_ВИД   // данный блок содержит общий вид задания
3. | Написать программу для вычисления функции y = f(x)
4. | 
5. |  y = @выражение 1@ где x1 < @1-ый диапазон@
6. |  y = @выражение 2@ где @1-ый диапазон@ <= x1 < @2-ой диапазон@
7. |  y = @выражение 3@ где @2-ой диапазон@ <= x1 < @3-ий диапазон@
8. |  y = @выражение 4@ где x1 >= @3-ий диапазон@
9. | 
10.| ----
11.| ХРАНИЛИЩЕ_ОБЪЕКТОВ // хранилище всех объектов-параметров
12.| выражение 1 : #genAE(5); // генерация арифм. выражений
13.| код 1 : #getAEcode();    // код на C++ для вычисления пред. выражения
14.| 
15.| выражение 2 : #genAE(5);
16.| код 2 : #getAEcode();
17.| 
18.| выражение 3 : #genAE(5);
19.| код 3 : #getAEcode();
20.| 
21.| выражение 4 : #genAE(5);
22.| код 4 : #getAEcode();
23.| // rnd (Random) - генерация случайного числа
24.| 1-ый диапазон : #rndDouble( 0.0  , 5.0); // в диапазоне [0.0; 5.0) типа double 
25.| 2-ой диапазон : #rndDouble( 5.0  , 10.0); // в диапазоне [5.0; 10.0) типа double
26.| 3-ий диапазон : #rndDouble( 10.0 , 15.0); // в диапазоне [10.0; 15.0) типа double
27.| 
28.| выражение 5: sin(x) + 88 * 99 - 123; // статическое выражение (если необходимо)
29.|
30.| ----
31.| РЕШЕНИЕ // данная секция хранит эталонное решение
32.| #include <cmath>
33.| #include <iostream>
34.| 
35.| using namespace std;
36.| 
37.| int main()
38.| {
39.|     double y = 0.0;
40.|     double x1;
41.|     cin >> x1;
42.| 
43.|     if ( x1 <  @1-ый диапазон@) // подстановка 1-го диапазона
44.|     {        
45.|         @код 1@ // подстановка сгенерированного кода для вычисления выражения 1
46.|     }
47.|     else if (x1 >=  @1-ый диапазон@ && x1 < @2-ой диапазон@) // диапазон 1 и 2
48.|     {
49.|         @код 2@ // подстановка сгенерированного кода для вычисления выражения 2
50.|     }
51.|     else if (x1 >= @2-ой диапазон@ && x1 < @3-ий диапазон@) // диапазон 2 и 3
52.|     {
53.|     	@код 3@ // подстановка сгенерированного кода для вычисления выражения 3
54.|     }
55.|     else if (x1 >= @3-ий диапазон@) // подстановка 3-го диапазона
56.|     {
57.|         @код 4@ // подстановка сгенерированного кода для вычисления выражения 4
58.|     }
59.|     cout << y << "\n";
60.|     system("pause");
61.|     return 0;
62.| }
63.| ----
64.| СЛУЖЕБНОЕ // данная секция хранит настройки генератора
65.|   знаки_арифм : + | - | * | / | ^;
66.| функции_арифм : sin | cos | sqrt | tan | log | log10;
67.| ----
68.| ТЕСТОВЫЕ_ДАННЫЕ // здесь хранятся тестовые данные для прогонов
69.| Тест1 : #rndDouble(100 , 200, 1000); //  генерация в ран тайме 1000 double значений
70.| Тест2 : 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0;
71.| ----
```

### **ШАБЛОННЫЙ_ВИД**
Первой секцией в листинге 3 является `ШАБЛОННЫЙ_ВИД`, блок в котором содержится генерируемое задание
> y = **@выражение 1@** где x1 < **@1-ый диапазон@**

Это 5-ая строка из листинга 3, выделенные части - это места в которые будут подставляться генерируемые данные, не выделенные части, соответсвенно остануться неизменны. В данном примере используются два объекта-параметра `@выражение 1@` и `@1-ый  диапазон@`, эти и остальные параметры хранятся в блоке `ХРАНИЛИЩЕ_ОБЪЕКТОВ`.

### **ХРАНИЛИЩЕ_ОБЪЕКТОВ**

`ХРАНИЛИЩЕ_ОБЪЕКТОВ` расположено в строках `11-27` и содержит в себе все объекты-параметры, применяемые в шаблоне. Объекты-параметры своего рода переменные, которые хранят либо уже готовый набор строк, либо исполняемую функцию.

Для примера обратимся к строке 12, здесь объекта-параметр `выражение 1` содержит исполняемую функцию `#genAE(5)` (расшифровывается как _generate arithmenic expression_), данная функция генерирует случайное арифметическое выражение сложность 5 (сумма знаков и функций, например: _sin_, _cos_, _log_, _+_, _-_ и т.д.).

Функция `#genAE(3)` например может сгенерировать выражение `cos((-2 / x1) * x1)`, сложность данного выражения 3 = `cos, знак / и знак *`. Сгенерированное выражение поместится в объект-параметр `выражение 1`

Подстановка:
```
до подстановки =
    y = @выражение 1@
после подстановки =
    y = cos((-2 / x1) * x1)
```

Далее обратимся к строке 13 к объекту-параметру `код 1` привязана функция `#getAEcode()` (расшифровывается как _get arithmenic expression code_), данная функция возвращает код на ЯП `C++` (вместе с проверками) для вычисления **последнего сгенерированного выражения функцией `#genAE()`**. 
```
до подстановки =
    y = @выражение 1@
    код = @код 1@
после подстановки =
    y = cos((-2 / x1) * x1)
    код = if (x1 != 0 ) y = cos((-2 / x1) * x1); else y = 0.0;
```

Из примера выше становится более понятно, что данные функции сильно связаны друг с другом.

Следующий уникальным объектом-параметром является `1-ый диапазон` и привязанная к нему функция `#rndDouble(0.0, 5.0)` (расшифровывается как _random double_). Функция вовзращает случайное число типа `double` из диапазона от 0.0 до 5.0 **не включая верхнюю границу**

```
до подстановки =
    y = @выражение 1@ где х1 < @1-ый диапазон@
    if ( x1 <  @1-ый диапазон@)
    {        
         @код 1@
    }

после подстановки =
    y = cos((-2 / x1) * x1) где х1 < 2.67
    if ( x1 <  2.67)
    {        
         if (x1 != 0 ) y = cos((-2 / x1) * x1); else y = 0.0;
    }
```

Есть еще один объект-параметр из строки 28 это `выражение 5 : sin(x) + 88 * 99 - 123`, данный параметр нигде не используется, он указан лишь для того чтобы показать как можно использовать заготовленные данные.

### **РЕШЕНИЕ**

`РЕШЕНИЕ` - потенциальное эталонное решение, созданное преподавателем и которое в дальнейшем будет использоваться для проверки студенческих работ. В листинге 3 данной блок расположен в строках 31-62, здесь все работает по тому же принципу как и в секции `ШАБЛОННЫЙ_ВИД`, есть общие места, а есть места подстановки объектов-параметров.

### **СЛУЖЕБНОЕ**

Предпоследний блок `СЛУЖЕБНОЕ`, находящийся в строках 64-66, служит для настройки генератора. На данный момент есть два значения `функции_арифм` и `знаки_арифм`, данные настройки отвечают за знаки и функции, которые будут использоваться при генерации арифметических выражений.

### **ТЕСТОВЫЕ_ДАННЫЕ**

Последний блок в шаблоне это `ТЕСТОВЫЕ_ДАННЫЕ`, находящийся в строках 68-70 и который содержит в себе тестовые данные, которые будут применяться при тестировании работ студентов, здесь также как и в `ХРАНИЛИЩЕ_ОБЪЕКТОВ` можно создавать объекты-параметры, которые будут содержать либо уже заготовленные тестовые данные строка 70 или содержать функцию `#rndDouble(100, 200, 1000)`, это все таже функция `Random`, лишь с тем отличием, что здесь создается не одно значение а сразу 1000.

# **Подробное описание блоков**

Шаблон задания состоит из пяти секций (листинг 3, строки: `2, 11, 31, 64, 68`), также необходимо обратить внимание на то, что начало каждой секции отделяется от предыдущей последовательностью символов : `----\n`, данная последовательность должна заканчиваться концом строки `\n`.

```         
1. | ----
2. | ШАБЛОННЫЙ_ВИД

10.| ----
11.| ХРАНИЛИЩЕ_ОБЪЕКТОВ

30.| ----
31.| РЕШЕНИЕ
      
63.| ----
64.| СЛУЖЕБНОЕ
      
67.| ----
68.| ТЕСТОВЫЕ_ДАННЫЕ   
```

## Примечание: 

Для более удобного расшифровывания шаблон-файл есть набор метасимволов, который предназначен для резделения лексем. К ним относятся [ `: ; | " @` ]. Eсли необходимо использовать эти символы в качестве текстовых знаков, можно использовать экранирующий символ [ `\` ]. При подстановке в текст символ [ `\` ] будет убираться.

***Данное правило относится лишь к объектам-параметрам, во всех остальных местах никакие экранирующие символы использовать не нужно.***

> ### Пример:
> **В данном случае все знаки используются для разделения лексем**
> - выражение 1 **:** sin x + 23 **|** x * 2 + x * x **;**
> 
> **В следующих примерах некоторые символы выступают в качестве текстовых знаков. При использовании данных объектов-параметров в тексте - символ `\` удалится**
> - задание : реализовать возведение в степень , не используя математическую библиотеку, для чисел в диапазоне [1 **\\;** 100];
> - оператор : оператор **\\|\\|** является логическим ИЛИ;


## **Секция № 1 - ХРАНИЛИЩЕ_ОБЪЕКТОВ**

`ХРАНИЛИЩЕ_ОБЪЕКТОВ` - хранит объекты-параметры. 

`Объект-параметр` - именованная переменная, хранящая строку (здесь подразумевается неограниченный набор символов). Объект-параметр может содержать как уже готовое значение так и исполняемую функцию (при вызове параметра где-либо в шаблоне функция сначала исполняется и подставляется уже результат, который выдала функция).

Объект-параметр имеет следующий синтаксис :
```
объект_параметр = “имя объекта-параметра” “:” значение { "|" значение} “;”
значение        =  наборы строк |
                  “#имя_функции({аргументы функции [,]})”
```
Если описывать проще то синтаксис можно представить следующим образом (пробелы не играют никакой роли):
```
имя параметра : содержимое объекта параметра;
  выражение 1 : решите выражение - sin(x) + x * 10 + 5 | #genAE(4) | 10 * x + 123;
```

1. Имя параметра может содержать любые символы (исключение составляют специальные символы - [ ` : , ; | " \n` ]);
2. Cодержимое может являться либо функцией либо уже готовым значением, перемешивание недопустимо;
3. Объекту-параметру изнально можно задать несколько значений, используя символ [ `|` ]. В дальнейшем выберется одно случайное значение, которое и будет использоваться.

Если выражение содержит несколько параметров, то можно выбрать необходимое значение путем указания ключа значения.


```
имя параметра [значение] : [ключ] содержимое объекта параметра;
1.  выражение 1 [0] : [0] sin(x) + x * 10 + 5 |
                      [1] #genAE(4) |
                      [2] 10 * x + 123;

2.  выражение 1 [1] : sin(x) + x * 10 + 5 | 
                      #genAE(4) | 
                      10 * x + 123;

3. выражение 1 [мой_ключ] : sin(x) + x * 10 + 5 |
                            #genAE(4) | 
                            [мой_ключ] 10 * x + 123;

4. случайное_значение : #rndInt(0,3);
   выражение 1 [@случайное_значение@] : sin(x) + x * 10 + 5 |
                                        #genAE(4) | 
                                        10 * x + 123;
```

Выше описано 4 примера выбора значения по ключу. По-умолчанию все значения пронумерованны от 0 до некоторого значения.
Можно явно указать ключ для каждого значения, заключив его в скобки `[ключ]`. Ключ может быть числом, строкой, набор символов и т.д.
Если необходимо выбрать случайное значение, то можно сгенерировать случайное число и использовать его в качестве ключа, так как это представлено в примере 4.

* В примере 1 будет выбрано `sin(x) + x * 10 + 5`
* В примере 2 будет выбрано `#genAE(4)`
* В примере 3 будет выбрано `10 * x + 123`

### **Стандартные функции**

#### Функция #genAE(x)
Обратимся к строкам: `12, 15, 18, 21`
```
12.| выражение 1 : #genAE(5);
15.| выражение 2 : #genAE(5);
18.| выражение 3 : #genAE(5);
21.| выражение 4 : #genAE(5);
```
Здесь объекты-параметры содержат исполняемую функцию `#genAE(х)` - данная функция генерирует арифметическое выражения сложностью `х` (сумма знаков и функций: sin, cos, log и т.д.).

Пример:
```
 было = выражение 1 : #genAE(5);
стало = выражение 1 : cos(-99.45 + log(51.01 - (18.82 * x1)));
```
#### Функция #getAEcode()
Теперь посмотрим на строки: `13, 16, 19, 22`
```
13.| код 1 : #getAEcode();
16.| код 2 : #getAEcode();
19.| код 3 : #getAEcode();
22.| код 4 : #getAEcode();
```
Здесь объекты-параметры содержат исполняемую функцию `#getAEcode()` - функция, генерирующая код на языке `C++` для вычисления последнего сгенерированного арифметическое выражения (код содержит само выражение, а также условия при которых оно вычисляется).

Пример :

```
было =
    выражение 1 : #genAE(5);
    код 1 : #getAEcode();

стало =
    выражение 1 : cos(-99.45 + log(51.01 - (18.82 * x1)));
    код 1 : if (((51.01 - (18.82 * x1)) > 0 && (51.01 - (18.82 * x1)) != 1))
                 y = cos(-99.45 + log(51.01 - (18.82 * x1)));
            else 
                 y = 0.0;
```
#### Функция #rndDouble(min, max)

Строки:  `24-26`
```
24.| 1-ый диапазон : #rndDouble( 0.0  , 5.0 );
25.| 2-ой диапазон : #rndDouble( 5.0  , 10.0);
26.| 3-ий диапазон : #rndDouble( 10.0 , 15.0);
```

Объекты-параметры из данных строк содержат исполняемую функцию `#rndDouble(min, max)` - функция, генерирующая случайное число в диапазоне [`min` ; `max`] типа `double`.

Пример:
```
 было = 1-ый диапазон : #rndDouble(1, 10);
стало = 1-ый диапазон : 5.67;
```

_Полное описание доступных функций будет изложено в конце документа._
### **Подстановка объектов-параметров**
На данном этапе стало более понятно что представляют собой объекты-параметры. Теперь нужно сказать о там как их использовать, все довольно просто, чтобы использовать параметр нужно прибегнуть к следующему синтаксису:
```
@имя_объекта_параметра@
```
**Между знаками `@` и `имя_объекта_параметра` пробелов быть не должно.**

Пример использования подстановок:
```
было = 
    количество : 100;
    задание: запишите в файл 'Input.txt' @количество@ знаков;

стало = 
    количество : 100;
    задание: запишите в файл 'Input.txt' 100 знаков;
```

## **Секция 2 - ШАБЛОННЫЙ_ВИД**

Данная секция шаблон-файла содержит конкретный вид варианта задания. В данном блоке можно и нужно использовать ранее описанные объекты-параметры.

Обратимся к строкам `1-8`
```
1. | ----
2. | ШАБЛОННЫЙ_ВИД
3. | Написать программу для вычисления выражения y = f(x):
4. | 
5. | - y = $@выражение 1@$ **где x1 < @1-ый диапазон@**
6. | - y = $@выражение 2@$ **где @1-ый диапазон@ <= x1 < @2-ой диапазон@**
7. | - y = $@выражение 3@$ **где @2-ой диапазон@ <= x1 < @3-ий диапазон@**
8. | - y = $@выражение 4@$ **где x1 >= @3-ий диапазон@**
```

Данный блок содержит задание в которое будут подставляться ранее описанные объекты-параметры: `@выражение 1@`, `@выражение 2@`, `@выражение 3@`, `@выражение 4@`, `@1-ый диапазон@`, `@2-ый диапазон@`, `@3-ый диапазон@`. 

Примечание:
Посмотрим на строку 5

> 5.| `-` y = `$`@выражение 1@`$` `**`где x1 < @1-ый диапазон@`**`

Помеченные символы являются частью языка разметки `markdown` и используются для форматирования текста, использование `markdown` не является обязательным, если у вас нет времени на изучение `markdown`, вы можете игнорировать использование данного языка и описывать все так как вы привыкли.

Примерный вид готового задания с использованием форматирования может выглядеть следующим образом:

> Написать программу для вычисления выражения $y = f(x)$:
> 
> - $y = \frac{x1}{-6} + 3$  **где x1 < 3**
> - $y = \log(\cos(2^{-6 * x1})))$  **где 3 <= x1 < 7**
> - $y = -10 + (\sin(9 - x1) * 8)$  **где 7 <= x1 < 14**
> - $y = \sqrt{6 * (-1 + x1)}$  **где x1 >= 14**

## **Секция 3 - РЕШЕНИЕ**

`РЕШЕНИЕ` - хранит эталонное решения для задания. Эталонное решение компилируется и используется для тестирования других программ предназначенных для выполнения поставленных задач.

Данная секция является копией `ШАБЛОННОГО_ВИДА`, здесь также можно использовать объекты-параметры. Отличительная черта данного блока это данные, а именно код который должен успешно компилироваться или интерпретироваться, привязки к определенному ЯП нет. Из _'коробки'_ генератор обращается к модулю проверки заданий, который компилирует эталонное решения, используя `g++` (подразумевается, что решение написано ЯП `C++`).

## **Секция 4 - СЛУЖЕБНОЕ**

`СЛУЖЕБНОЕ` - секция отвечающая за настройку генератора. На данный момент есть лишь 2 параметра :

* `знаки_арифм` – отвечает за операции, которые будут использоваться во время генерации арифметических выражений;
* `функции_арифм` – отвечает за функции, которые будут использоваться во время генерации арифметических выражений.

## **Секция 5 - ТЕСТОВЫЕ_ДАННЫЕ**

`ТЕСТОВЫЕ_ДАННЫЕ` - секция которая содержит данные для тестирования эталонного решения и решения, присланного обучаемым;

Данный блок схож с `ХРАНИЛИЩЕМ_ОБЪЕКТОВ`, здесь также описываются объекты-параметры. В данной секции можно указывать заготовленные данные через запятую или же использовать какие-либо функции, например использовать функцию для генерации большого количества случайных чисел в диапазоне и т.д.


# Полное описание доступных функций:
 * `#rndInt( нижняя_граница , верхняя_граница {, количество})` - генерирует случайное число в границе [ нижняя_граница, верхняя_граница) целого типа. Если необходимо сгенерировать сразу несколько значений используется дополнительный параметр “количество”, в таком случае сгенерированные числа будут разделены запятыми;
 * `#rndDouble( нижняя_граница , верхняя_граница {, количество})` - тоже самое что и rndInt, но генерирует числа с плавающей точкой двойной точности;
    ```
     было = число : #rndInt(1, 10);
    стало = число : 5;

     было = число : #rndDouble(1.0, 10.0);
    стало = число : 3.14;
    ```
 * `#genAE(сложность {, граница , тип , количество переменных})` - генерирует выражение некоторой сложности (сложность указывает количество знаков и функций (например log, sin и т.д.)), граница указывает диапазон генерации констант [-граница, граница) по-умолчанию = [-100; 100), тип указывает на тип генерируемых констант (`double` или `int`), по-умолчанию = int, количество переменных, указывает на зависимость выражения от количества переменных (от 1 до бесконечности), по-умолчанию = 1.
    ```
     было = выр : #genAE(5);
    стало = выр : cos(-99 + log(51 - (10 * x1)));

     было = выр2 : #genAE(5 , 50.0 , double , 2);
    стало = выр2 : (x2 / ((x2 + tan(x1)) * 18.82)) + x1;
    ```
 * `#getAEcode()` - возвращает код для вычисления последнего сгенерированного выражения на языке `C++`.
    ```
    было =
        выр : #genAE(5, 100, double);
        код : #getAEcode();

    стало =
        выр : cos(-99.45 + log(51.01 - (18.82 * x1)));
        код : if (((51.01 - (18.82 * x1)) > 0 && (51.01 - (18.82 * x1)) != 1))
                   y = cos(-99.45 + log(51.01 - (18.82 * x1)));
              else 
                   y = 0.0;
    ```
 * `#lua(код_на_луа)` - данная функция является второстепенной и предназначена для выполнения кода на `Lua` (изначально предполагалось использовать `Lua` лишь для вычисления мат. выражений, но в дальнейшем данный язые будет использовать для расширения предоставляемого функционала генератора). Все системные функции (кроме получения времени и даты) на `Lua` которые обращаются к OS запрещены в целях безопасности.
    ```
    было =
        число : #lua("
                math.randomseed(12345689);
                return math.random(100);
            ");
    стало =
        число : 88;
    ```
 * #путь_до_модуля.метод(аргументы) - это способ расширения стандратного набора функций с помощью скриптов написанных на `lua`. Допустим вам необходима функция которой нет, вы можете написать модуль на `lua`, поместить данный модуль в какую-либо директорию и вызвать ее описанным способом. Путь до модуля может быть как полным, так и относительным.
    ```
    Внешний модуль написанный на lua. Имя файла rnd_arr.lua. Расположен в поддиректории my_modules.
    Дерево директории Generator:
    ---
    |--*.dll *.json другие директории
    | 
    |--Generator.exe
    |--Generator.dll
    |
    |--my_modules
            |
            |--rnd_arr.lua

    --------------------
    МОДУЛЬ rnd_arr.lua
    --------------------
    lib = {}
    -- перевод в строку не обращайте внимания
    function table_to_string(tbl)
        local result = ""
        for k, v in pairs(tbl) do
            if type(k) == "string" then
                result = result.."[\""..k.."\"]".."="
            end
            
            if type(v) == "table" then
                result = result..table_to_string(v)
            elseif type(v) == "boolean" then
                result = result..tostring(v)
            else
                result = result..v
            end
            result = result..","
        end

        if result ~= "" then
            result = result:sub(1, result:len()-1)
        end
        return result
    end

    -- генерация упорядоченного массива
    function lib.make_array(count, min, max)
        math.randomseed(os.time()) -- задаем случайное зерно
        local digits = {} -- массив с числами
        for i = 1,count do -- генерация новых значений
            digits[i] = math.random( min,max )
        end
        -- сортировка
        table.sort(digits, function (a, b) return (a < b) end)
        -- возвращаем строку
        return table_to_string(digits)
    end

    return lib -- возвращаем модуль
    --------------------
    Вызов метода из внешнего модуля

    модуль : my_modules/rnd_arr;
    массив1 : #@модуль@.make_array(100,-250.0, 250.0); // способ 1
    массив2 : #my_modules/rnd_arr.make_array(100,-250.0, 250.0); // способ 2
    ```

